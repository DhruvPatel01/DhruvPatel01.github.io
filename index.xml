<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dhruv Patel</title><link>https://dhruvpatel.dev/</link><description>Recent content on Dhruv Patel</description><generator>Hugo</generator><language>en</language><copyright>Dhruv Patel</copyright><lastBuildDate>Mon, 21 Apr 2025 09:05:38 +0000</lastBuildDate><atom:link href="https://dhruvpatel.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>(Re)building Gemma tokenizer in Python</title><link>https://dhruvpatel.dev/posts/gemma3_tokenizer/</link><pubDate>Mon, 21 Apr 2025 09:05:38 +0000</pubDate><guid>https://dhruvpatel.dev/posts/gemma3_tokenizer/</guid><description>&lt;blockquote>
&lt;p>[!NOTE] This is not a tutorial type blog. Think of this as my notes as I was going through the building tokenizer phase.&lt;/p>&lt;/blockquote>
&lt;p>First thing first, let&amp;rsquo;s download the model files. I mean tokenizer files. But, they end with &lt;code>.model&lt;/code>. These are serialized using ProtoBuf. You can find the specification of the file &lt;a href="https://github.com/google/sentencepiece/blob/master/src/sentencepiece_model.proto">here&lt;/a>. You can download the model file from &lt;a href="https://huggingface.co/google/gemma-3-27b-it/blob/main/tokenizer.model">here&lt;/a>.&lt;/p>
&lt;p>Gemma-3 tokenizer is different than Gemma-2. Algorithm remains same, vocabulary size is also more or less similar (256K vs ~262K). Within gemma3 variants, the same tokenizers are used.&lt;/p></description></item><item><title>What I was doing earlier?</title><link>https://dhruvpatel.dev/now/archive/</link><pubDate>Fri, 08 Mar 2024 00:00:00 +0000</pubDate><guid>https://dhruvpatel.dev/now/archive/</guid><description>&lt;p>&lt;small>(This is an archival of my &lt;a href="https://nownownow.com/about">now page&lt;/a>.)&lt;/small>&lt;/p>
&lt;p>&lt;small>Updated: 23rd May 2023&lt;/small>&lt;/p>
&lt;p>Last week I started learning to swim. Just today I finished &amp;ldquo;Godel&amp;rsquo;s Proof&amp;rdquo; by Nagel and Newman. It was a wonderful book. However, such a short book did not go deeper in the topic. I am glad though, as my understanding of logic is not that good.
I also started reading &amp;ldquo;The Seasoned Schemer&amp;rdquo;, and &amp;ldquo;Designing Data Intensive Applications&amp;rdquo;. I am planning to take DDIA slowly and target to finish it in 6 months.&lt;/p></description></item><item><title>Gödel's Proof: Book Notes</title><link>https://dhruvpatel.dev/notes/cs/godels_proofs/</link><pubDate>Tue, 23 May 2023 00:00:00 +0000</pubDate><guid>https://dhruvpatel.dev/notes/cs/godels_proofs/</guid><description>My book summary for the book by Ernest Nagel and James Newman.</description></item><item><title>Quantum Mechanics Notes</title><link>https://dhruvpatel.dev/notes/physics/theoretical_minimum/qm-notes/</link><pubDate>Sat, 14 Jan 2023 04:02:28 +0000</pubDate><guid>https://dhruvpatel.dev/notes/physics/theoretical_minimum/qm-notes/</guid><description>&lt;h1 id="quantum-mechanics">Quantum Mechanics&lt;/h1>
&lt;h2 id="differences-from-classical-mechanics">Differences from Classical Mechanics&lt;/h2>
&lt;ol>
&lt;li>States have different logical structure than CM.&lt;/li>
&lt;li>States and measurements are different unlike CM. e.g., Position and Momemntum can be determined by experiments in CM.&lt;/li>
&lt;/ol>
&lt;h2 id="spins">Spins&lt;/h2>
&lt;p>Particles have properties attached to it. e.g., mass, electric charge.&lt;/p>
&lt;p>Even a specific particle is not completely specified by its position.&lt;/p>
&lt;p>Attached to electron is an extra degree of freedom, called spin. Spin is as quantum mechanical as it can and we should not try to visualize it.&lt;/p></description></item><item><title>CM-Notes</title><link>https://dhruvpatel.dev/notes/physics/theoretical_minimum/cm-notes/</link><pubDate>Wed, 05 Oct 2022 02:01:42 +0000</pubDate><guid>https://dhruvpatel.dev/notes/physics/theoretical_minimum/cm-notes/</guid><description>&lt;h2 id="notation">Notation&lt;/h2>
&lt;p>$ F_i(\{q\}) $ is the force on ith particle. $ \{q\} $ is the set of cordinates of all particles.&lt;/p>
&lt;p>If there are N particles in the system,&lt;/p>
&lt;p>Configration space: 3N dimensional space, records positions.&lt;/p>
&lt;p>State space: 6N dimensional space, records position and velocity.&lt;/p>
&lt;p>Phase space: 6N dimesnional space, records position and momentum.&lt;/p>
&lt;h2 id="newtons-second-law">Newton&amp;rsquo;s second law&lt;/h2>
&lt;p>gives us 6N equations.&lt;/p>
&lt;p>$$
\begin{align*}
\dot{p}_i &amp;amp;= F_i(\{q\}) \\
\dot{q}_i &amp;amp;= \frac{p_i}{m_i}
\end{align*}
$$&lt;/p></description></item><item><title>Bloom Filters</title><link>https://dhruvpatel.dev/notes/cs/algorithms/bloom_filters/</link><pubDate>Thu, 29 Sep 2022 04:07:39 +0000</pubDate><guid>https://dhruvpatel.dev/notes/cs/algorithms/bloom_filters/</guid><description>&lt;h2 id="api">API&lt;/h2>
&lt;ul>
&lt;li>&lt;code>bf.add(x)&lt;/code>: adds x in the data structure&lt;/li>
&lt;li>&lt;code>x in bf&lt;/code>: tests if x is in the data structure.&lt;/li>
&lt;/ul>
&lt;h2 id="why-not-use-set-or-dict">Why not use Set or Dict?&lt;/h2>
&lt;ul>
&lt;li>Bloom filters are more space efficients. They take memory lesser than the keys themselves.&lt;/li>
&lt;/ul>
&lt;h2 id="cons">Cons&lt;/h2>
&lt;ul>
&lt;li>can&amp;rsquo;t store associated data.&lt;/li>
&lt;li>does not support deletions.&lt;/li>
&lt;li>It is probabilistic data structure. That means, &lt;code>x in bf&lt;/code> might have false positives. There are no false negatives.&lt;/li>
&lt;/ul>
&lt;h2 id="applications">Applications&lt;/h2>
&lt;ul>
&lt;li>Spell checkers: (40 years ago) Add the dictionary into the filter. If the word is in the bloom filter, it is higly likely tobe correctly spelled word.&lt;/li>
&lt;li>list of forbidden password. E.g., too common password.&lt;/li>
&lt;li>Modern applications: Routers, a lot of packets incoming.&lt;/li>
&lt;/ul>
&lt;h2 id="how-does-it-work">How does it work?&lt;/h2>
&lt;ul>
&lt;li>we have a data set &lt;code>S&lt;/code> of size &lt;code>|S|&lt;/code>.&lt;/li>
&lt;li>have an array of &lt;code>n&lt;/code> bits.&lt;/li>
&lt;li>$b = \frac{n}{|S|}$ bits per element.&lt;/li>
&lt;li>have &lt;code>k&lt;/code> hash functions.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> numpy &lt;span style="color:#66d9ef">as&lt;/span> np
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BitArray&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __init__(self, n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>array &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>zeros((n &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, dtype&lt;span style="color:#f92672">=&lt;/span>np&lt;span style="color:#f92672">.&lt;/span>uint8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">set&lt;/span>(self, i):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i, j &lt;span style="color:#f92672">=&lt;/span> divmod(i, &lt;span style="color:#ae81ff">8&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>array[i] &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>array[i] &lt;span style="color:#f92672">|&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> j)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get&lt;/span>(self, i):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i, j &lt;span style="color:#f92672">=&lt;/span> divmod(i, &lt;span style="color:#ae81ff">8&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> bool(self&lt;span style="color:#f92672">.&lt;/span>array[i] &lt;span style="color:#f92672">&amp;amp;&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> j))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> xxhash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_hashes_for_str&lt;/span>(x, k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Only h1 and h2 are computed afresh. Remaining hash &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># functions are just linear combinations of h1 and h2.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">assert&lt;/span> k &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> h1 &lt;span style="color:#f92672">=&lt;/span> xxhash&lt;span style="color:#f92672">.&lt;/span>xxh64_intdigest(x, seed&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">42&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> h2 &lt;span style="color:#f92672">=&lt;/span> xxhash&lt;span style="color:#f92672">.&lt;/span>xxh64_intdigest(x, seed&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">84&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hashes &lt;span style="color:#f92672">=&lt;/span> [h1, h2]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">2&lt;/span>, k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hashes&lt;span style="color:#f92672">.&lt;/span>append(h1 &lt;span style="color:#f92672">+&lt;/span> i&lt;span style="color:#f92672">*&lt;/span>h2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> hashes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BloomFilter&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __init__(self, n, k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>array &lt;span style="color:#f92672">=&lt;/span> BitArray(n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>k &lt;span style="color:#f92672">=&lt;/span> k
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>n &lt;span style="color:#f92672">=&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(self, key):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> h &lt;span style="color:#f92672">in&lt;/span> get_hashes_for_str(key, self&lt;span style="color:#f92672">.&lt;/span>k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>array&lt;span style="color:#f92672">.&lt;/span>set(h &lt;span style="color:#f92672">%&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __contains__(self, key):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> h &lt;span style="color:#f92672">in&lt;/span> get_hashes_for_str(key, self&lt;span style="color:#f92672">.&lt;/span>k):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">not&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>array&lt;span style="color:#f92672">.&lt;/span>get(h &lt;span style="color:#f92672">%&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>n):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>text &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;correct incorrect&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>split()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bm &lt;span style="color:#f92672">=&lt;/span> BloomFilter(&lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> word &lt;span style="color:#f92672">in&lt;/span> text:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bm&lt;span style="color:#f92672">.&lt;/span>add(word)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> word &lt;span style="color:#f92672">in&lt;/span> text:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">assert&lt;/span> word &lt;span style="color:#f92672">in&lt;/span> bm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">assert&lt;/span> &lt;span style="color:#e6db74">&amp;#34;notcorrect&amp;#34;&lt;/span> &lt;span style="color:#f92672">not&lt;/span> &lt;span style="color:#f92672">in&lt;/span> bm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="analysis">Analysis&lt;/h2>
&lt;p>Trade off between erro rate and space required. Data structre will be useful when there is a sweetspot on the tradeoff curve.&lt;/p></description></item><item><title>Power and Politics in Today’s World</title><link>https://dhruvpatel.dev/notes/politics/power/</link><pubDate>Sat, 10 Sep 2022 09:07:23 +0000</pubDate><guid>https://dhruvpatel.dev/notes/politics/power/</guid><description>&lt;h1 id="lecture-2">Lecture 2&lt;/h1>
&lt;p>&lt;strong>Aug 19, 1991 Moskow&lt;/strong>: &lt;a href="https://en.wikipedia.org/wiki/1991_Soviet_coup_d%27%C3%A9tat_attempt">Coup d&amp;rsquo;etat against Mikhail Gorbichov&lt;/a> (came power in Feb 1985)&lt;/p>
&lt;p>When came to power in 1985, west thought what would become of Soviet Union?&lt;/p>
&lt;p>Gorbachev was younger, talked like a western politician, allowed criticism of the regime. His policies were more open. It seemed like it was starting to change. In 1989 while revolution in Eastern Europe, Russia didn&amp;rsquo;t intervene; this was opposite to Russia&amp;rsquo;s earlier policies. He was seen as a radical reformer. He was getting push back for his ideas.&lt;/p></description></item><item><title>Convex Optimization</title><link>https://dhruvpatel.dev/notes/maths/convex_optimization/convex_optimization/</link><pubDate>Fri, 26 Aug 2022 07:31:53 +0000</pubDate><guid>https://dhruvpatel.dev/notes/maths/convex_optimization/convex_optimization/</guid><description>&lt;h1 id="convex-optimization">Convex Optimization&lt;/h1>
&lt;!--eofm-->
&lt;p>Note:
These notes are not mathematically rigorous. These are meant for quick reference, please read the &lt;a href="https://web.stanford.edu/~boyd/cvxbook/">Convex Optimization book&lt;/a> from Boyd and Vandenberghe for more rigorous treatment.&lt;/p>
&lt;h2 id="chapter-2-convex-sets">Chapter 2: Convex Sets&lt;/h2>
&lt;h3 id="sets">Sets&lt;/h3>
&lt;h4 id="affine-sets">Affine Sets&lt;/h4>
&lt;p>Affine combination: $\sum_{i=1}^{i=N} \theta_i x_i$ such that $\sum_{i=1}^{i=N} \theta_i = 1$.&lt;/p>
&lt;p>Draw a line passing through any two points, if the whole line is in the set, the set is affine.&lt;/p>
&lt;p>Every affine set C can be written as $C = V + x_0$ for any $x_0 \in C$, where V is a subspace.&lt;/p></description></item><item><title>Analysis (Not Rigorous) Notes</title><link>https://dhruvpatel.dev/notes/maths/analysis/</link><pubDate>Sun, 10 Jul 2022 18:37:29 +0530</pubDate><guid>https://dhruvpatel.dev/notes/maths/analysis/</guid><description>&lt;h2 id="definitions">Definitions&lt;/h2>
&lt;dl>
&lt;dt>Interior Point $x \in C$&lt;/dt>
&lt;dd>A point is an interior point if we can find &lt;strong>a&lt;/strong> ball around x which is completely inside C.&lt;/dd>
&lt;dt>Open Set&lt;/dt>
&lt;dd>A set is open, if all points are interior points.&lt;/dd>
&lt;dt>Closed Set&lt;/dt>
&lt;dd>A set is closed, if its complement is open.&lt;/dd>
&lt;dt>Closure&lt;/dt>
&lt;dd>Take the set&amp;rsquo;s complement. Find its interior. Take the complement of it. You got a closure.&lt;/dd>
&lt;dd>
&lt;p>A point is in a closure, if for &lt;strong>every&lt;/strong> $\epsilon$, you can find a point from the original set within $\epsilon$ distance.&lt;/p></description></item><item><title>Can we do better than NumPy in special cases?</title><link>https://dhruvpatel.dev/posts/matrix_vector/</link><pubDate>Sun, 10 Apr 2022 09:11:23 +0530</pubDate><guid>https://dhruvpatel.dev/posts/matrix_vector/</guid><description>&lt;h2 id="can-we">Can we?&lt;/h2>
&lt;p>Yes. This blog explains how I did. If you want to follow the whole code, you can download the source code from &lt;a href="https://github.com/DhruvPatel01/notebooks/tree/main/High_Performance_Computing/mat_vec">GitHub repository.&lt;/a>&lt;/p>
&lt;h2 id="why-would-we">Why would we?&lt;/h2>
&lt;p>Good question. NumPy is great. It is fast. Beating it would be hard. Even if we beat it, will it be worth it? Probably not. You would quote Donald Knuth and say that premature optimization is the root of all evil. I am trying to justify this blog by asking What if this is not a premature optimization? I would have tried other optimizations, and now I would want to see if I can squeeze out anything else.&lt;/p></description></item><item><title>Why the solution to part 2(AoC21-Day7) works?</title><link>https://dhruvpatel.dev/posts/aoc/21/day7/</link><pubDate>Tue, 07 Dec 2021 16:28:35 +0530</pubDate><guid>https://dhruvpatel.dev/posts/aoc/21/day7/</guid><description>&lt;h2 id="problem">Problem&lt;/h2>
&lt;p>We are given an array of integers, $x_1, x_2, \dots, x_N.$ We want to find an $x$ (also an integer) that minimizes some cost function.&lt;/p>
&lt;p>$$
argmin_x \sum_{i=1}^N f(x_i, x)
$$&lt;/p>
&lt;p>Part 1 has a simple cost function, L1 distance. i.e. $f(x_i, x) = | x_i - x|$. Even with non-differentiability, there is a closed form solution to this function, a median. The proofs are there on the Internet, or the book Probability and Computing[1].&lt;/p></description></item><item><title>Why Blelloch Scan Works</title><link>https://dhruvpatel.dev/posts/why_blelloch_scan_works/</link><pubDate>Sat, 02 Oct 2021 09:31:44 +0530</pubDate><guid>https://dhruvpatel.dev/posts/why_blelloch_scan_works/</guid><description>&lt;p>Blelloch scan is a (exclusive) scan algorithm for parallel computers. A common example of scan is prefix sum.&lt;/p>



&lt;details class="collapsable-code" >
 &lt;summary title="Click to interact">&lt;span class="collapsable-code__title">sequential.py&lt;/span>&lt;/summary>
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">exclusive_scan&lt;/span>(a, op):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#75715e"># Identity of the op, (for sum and max, it is 0).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> x &lt;span style="color:#f92672">in&lt;/span> a[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b&lt;span style="color:#f92672">.&lt;/span>append(op(x, b[&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exclusive_scan([&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>], &lt;span style="color:#66d9ef">lambda&lt;/span> x, y: x&lt;span style="color:#f92672">+&lt;/span>y) &lt;span style="color:#f92672">==&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exclusive_scan([&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>], max) &lt;span style="color:#f92672">==&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>]&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/details>

&lt;p>This vlog is complementary to the excellent &lt;a href="https://youtu.be/mmYv3Haj6uc">video description&lt;/a> from now archived Udacity CS344 course. The video explains the &amp;ldquo;how&amp;rdquo; of the algorithm very well, but I couldn&amp;rsquo;t easily find &amp;ldquo;why&amp;rdquo; of the algorithm, neither in that video nor in any other videos on the Internet. So here is my attempt to explain it.&lt;/p></description></item><item><title>Python got me with circular imports!</title><link>https://dhruvpatel.dev/posts/python_circular_imports/</link><pubDate>Wed, 14 Apr 2021 21:51:48 +0530</pubDate><guid>https://dhruvpatel.dev/posts/python_circular_imports/</guid><description>&lt;p>I have been programming in Python from last seven years. Apart from the new features Python adds in every new release, I didn&amp;rsquo;t think Python would surprise me, until it did.&lt;/p>
&lt;p>I will demonstrate what happened with the trimmed down code. I have two files, &lt;code>main.py&lt;/code> and &lt;code>notmain.py&lt;/code>. &lt;code>main.py&lt;/code> has a global variable called &lt;code>var&lt;/code>. &lt;code>notmain&lt;/code> has some code that would process user input and add entry into &lt;code>main.var&lt;/code>. Pretty simple, right?&lt;/p></description></item><item><title>NotAeroCalc Part 1: What is NotAeroCalc and how to use it?</title><link>https://dhruvpatel.dev/posts/notaerocalc/notaerocalc_part1/</link><pubDate>Sat, 03 Apr 2021 18:04:02 +0530</pubDate><guid>https://dhruvpatel.dev/posts/notaerocalc/notaerocalc_part1/</guid><description>&lt;p>I am a Computer Engineer by education and by training. Luckily, we computer engineers do not have to deal with different units. All our units are power of 2. We have sensible names, Kilo, Mega, Giga, you get it. When we get unlucky, there could be a confusion of whether Kilo in the context is $ 2^{10} $ or $ 10^3 $. But that is it.&lt;/p>
&lt;p>But in other engineering (and science) branches this is not the case. A while ago I was taking a course &amp;ldquo;Introduction Aeronautical Engineering&amp;rdquo; on edX (the course is from TUDelft). Honestly, the homework problems there were annoying, at least for me. I can understand that students in the Aero department might need to practice the conversion process.&lt;/p></description></item><item><title>How to find the number of unique elements in a stream?</title><link>https://dhruvpatel.dev/posts/flajolet-martin/</link><pubDate>Mon, 29 Mar 2021 14:36:16 +0530</pubDate><guid>https://dhruvpatel.dev/posts/flajolet-martin/</guid><description>&lt;p>So, I&amp;rsquo;ve been reading about streaming algorithms. Seems like the journey to streaming algorithms(aka Algorithms for Big Data) starts with the Flajolet-Martin algorithm.&lt;/p>
&lt;h2 id="the-problem">The Problem&lt;/h2>
&lt;p>We are given a sequence &lt;code>&amp;lt;u_0, u_1, u_2, u_3, ... , u_n&amp;gt;&lt;/code> of &lt;code>n&lt;/code> elements. Each &lt;code>u_i&lt;/code> comes from the fixed set &lt;code>U&lt;/code> of some finite size. We want to see how many elements are unique.&lt;/p>
&lt;p>A simple Python code like below can solve the problem, if we have required memory.&lt;/p></description></item><item><title>About Me</title><link>https://dhruvpatel.dev/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dhruvpatel.dev/about/</guid><description>&lt;p>Hi, I am Dhruv. As a Senior Data Scientist at &lt;a href="https://www.myntra.com">Myntra&lt;/a>, I work on personalised size recommendation models. I graduated from the department of Computer Science and Automation at Indian Institute of Science in 2019. There I worked mostly on image segmentation problem and little bit on using machine learning on graph like structures.&lt;/p>
&lt;p>You can reach out to me at &lt;code>hello at domain&lt;/code>.&lt;/p></description></item><item><title>Talks I have given</title><link>https://dhruvpatel.dev/talks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dhruvpatel.dev/talks/</guid><description>&lt;h2 id="monte-carlo-markov-chains-and-pymc3">Monte Carlo Markov Chains and PyMC3&lt;/h2>
&lt;p>The talk given at Myntra starts with an introduction to the Bayesian Linear Regression. I explain analytic solution and also introduce PyMC3 based solution. Then I proceed to explain Markov Chains that were used by PyMC internally. In the process Metropolis-Hastings and Gibbs chain are explained. The notebook is available &lt;a href="https://github.com/DhruvPatel01/myntra_talks/blob/master/bayesian_intro_with_pymc.ipynb">here&lt;/a>. For proofs there is a &lt;a href="https://github.com/DhruvPatel01/myntra_talks/blob/master/mcmc.pdf">supplementary pdf&lt;/a>.&lt;/p>
&lt;h2 id="on-double-precision-floating-points">On Double Precision Floating Points&lt;/h2>
&lt;p>In this talk, I introduced subtleties of using floating points to the audience. Talk starts with a classic mistake done in the Patriot Missile system, which caused the lives of 28 soldiers. Then I introduce a naive/intuitive algorithm of computing variance online (i.e. in one pass) and dangers of it. While explaining what caused the issues in the naive algorithm, I explain how different programming languages might give different results while working with floats(doubles). I then explain the Achilles&amp;rsquo; heel of floating point arithmetic called catastrophic calculation, and how to avoid it. Talk concludes with Welford&amp;rsquo;s algorithm on computing variance online. Slides are available &lt;a href="https://dhruvpatel.dev/slides/floats.slides.html">here&lt;/a>.&lt;/p></description></item></channel></rss>