<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on Dhruv Patel</title><link>https://dhruvpatel.dev/tags/python/</link><description>Recent content in Python on Dhruv Patel</description><generator>Hugo</generator><language>en-us</language><copyright>Dhruv Patel</copyright><lastBuildDate>Sun, 10 Apr 2022 09:11:23 +0530</lastBuildDate><atom:link href="https://dhruvpatel.dev/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Can we do better than NumPy in special cases?</title><link>https://dhruvpatel.dev/posts/matrix_vector/</link><pubDate>Sun, 10 Apr 2022 09:11:23 +0530</pubDate><guid>https://dhruvpatel.dev/posts/matrix_vector/</guid><description>&lt;h2 id="can-we"&gt;Can we?&lt;/h2&gt;
&lt;p&gt;Yes. This blog explains how I did. If you want to follow the whole code, you can download the source code from &lt;a href="https://github.com/DhruvPatel01/notebooks/tree/main/High_Performance_Computing/mat_vec"&gt;GitHub repository.&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="why-would-we"&gt;Why would we?&lt;/h2&gt;
&lt;p&gt;Good question. NumPy is great. It is fast. Beating it would be hard. Even if we beat it, will it be worth it? Probably not. You would quote Donald Knuth and say that premature optimization is the root of all evil. I am trying to justify this blog by asking What if this is not a premature optimization? I would have tried other optimizations, and now I would want to see if I can squeeze out anything else.&lt;/p&gt;</description></item><item><title>Python got me with circular imports!</title><link>https://dhruvpatel.dev/posts/python_circular_imports/</link><pubDate>Wed, 14 Apr 2021 21:51:48 +0530</pubDate><guid>https://dhruvpatel.dev/posts/python_circular_imports/</guid><description>&lt;p&gt;I have been programming in Python from last seven years. Apart from the new features Python adds in every new release, I didn&amp;rsquo;t think Python would surprise me, until it did.&lt;/p&gt;
&lt;p&gt;I will demonstrate what happened with the trimmed down code. I have two files, &lt;code&gt;main.py&lt;/code&gt; and &lt;code&gt;notmain.py&lt;/code&gt;. &lt;code&gt;main.py&lt;/code&gt; has a global variable called &lt;code&gt;var&lt;/code&gt;. &lt;code&gt;notmain&lt;/code&gt; has some code that would process user input and add entry into &lt;code&gt;main.var&lt;/code&gt;. Pretty simple, right?&lt;/p&gt;</description></item><item><title>NotAeroCalc Part 1: What is NotAeroCalc and how to use it?</title><link>https://dhruvpatel.dev/posts/notaerocalc/notaerocalc_part1/</link><pubDate>Sat, 03 Apr 2021 18:04:02 +0530</pubDate><guid>https://dhruvpatel.dev/posts/notaerocalc/notaerocalc_part1/</guid><description>&lt;p&gt;I am a Computer Engineer by education and by training. Luckily, we computer engineers do not have to deal with different units. All our units are power of 2. We have sensible names, Kilo, Mega, Giga, you get it. When we get unlucky, there could be a confusion of whether Kilo in the context is $ 2^{10} $ or $ 10^3 $. But that is it.&lt;/p&gt;
&lt;p&gt;But in other engineering (and science) branches this is not the case. A while ago I was taking a course &amp;ldquo;Introduction Aeronautical Engineering&amp;rdquo; on edX (the course is from TUDelft). Honestly, the homework problems there were annoying, at least for me. I can understand that students in the Aero department might need to practice the conversion process.&lt;/p&gt;</description></item><item><title>How to find the number of unique elements in a stream?</title><link>https://dhruvpatel.dev/posts/flajolet-martin/</link><pubDate>Mon, 29 Mar 2021 14:36:16 +0530</pubDate><guid>https://dhruvpatel.dev/posts/flajolet-martin/</guid><description>&lt;p&gt;So, I&amp;rsquo;ve been reading about streaming algorithms. Seems like the journey to streaming algorithms(aka Algorithms for Big Data) starts with the Flajolet-Martin algorithm.&lt;/p&gt;
&lt;h2 id="the-problem"&gt;The Problem&lt;/h2&gt;
&lt;p&gt;We are given a sequence &lt;code&gt;&amp;lt;u_0, u_1, u_2, u_3, ... , u_n&amp;gt;&lt;/code&gt; of &lt;code&gt;n&lt;/code&gt; elements. Each &lt;code&gt;u_i&lt;/code&gt; comes from the fixed set &lt;code&gt;U&lt;/code&gt; of some finite size. We want to see how many elements are unique.&lt;/p&gt;
&lt;p&gt;A simple Python code like below can solve the problem, if we have required memory.&lt;/p&gt;</description></item></channel></rss>