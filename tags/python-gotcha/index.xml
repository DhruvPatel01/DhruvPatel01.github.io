<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python-gotcha on Dhruv Patel</title><link>https://dhruvpatel.dev/tags/python-gotcha/</link><description>Recent content in python-gotcha on Dhruv Patel</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Dhruv Patel</copyright><lastBuildDate>Wed, 14 Apr 2021 21:51:48 +0530</lastBuildDate><atom:link href="https://dhruvpatel.dev/tags/python-gotcha/index.xml" rel="self" type="application/rss+xml"/><item><title>Python got me with circular imports!</title><link>https://dhruvpatel.dev/posts/python_circular_imports/</link><pubDate>Wed, 14 Apr 2021 21:51:48 +0530</pubDate><guid>https://dhruvpatel.dev/posts/python_circular_imports/</guid><description>I have been programming in Python from last seven years. Apart from the new features Python adds in every new release, I didn&amp;rsquo;t think Python would surprise me, until it did.
I will demonstrate what happened with the trimmed down code. I have two files, main.py and notmain.py. main.py has a global variable called var. notmain has some code that would process user input and add entry into main.var. Pretty simple, right?</description><content>&lt;p>I have been programming in Python from last seven years. Apart from the new features Python adds in every new release, I didn&amp;rsquo;t think Python would surprise me, until it did.&lt;/p>
&lt;p>I will demonstrate what happened with the trimmed down code. I have two files, &lt;code>main.py&lt;/code> and &lt;code>notmain.py&lt;/code>. &lt;code>main.py&lt;/code> has a global variable called &lt;code>var&lt;/code>. &lt;code>notmain&lt;/code> has some code that would process user input and add entry into &lt;code>main.var&lt;/code>. Pretty simple, right?&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="296358471" type="checkbox" />
&lt;label for="296358471">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__title">main.py&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Hide" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
import notmain
var = {}
def work():
print(&amp;#34;Before:&amp;#34;, var)
notmain.populate()
print(&amp;#34;After: &amp;#34;, var)
if __name__ == &amp;#39;__main__&amp;#39;:
work()
&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="collapsable-code">
&lt;input id="638174592" type="checkbox" />
&lt;label for="638174592">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__title">notmain.py&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Hide" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
import main
def populate():
main.var[&amp;#39;answer&amp;#39;] = 42
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>What do you think will happen when I run &lt;code>python main.py&lt;/code>? Don&amp;rsquo;t know about you, but I imagined that after I call &lt;code>notmain.populate&lt;/code>, &lt;code>main.var&lt;/code> will have one key, value in it.&lt;/p>
&lt;pre tabindex="0">&lt;code>Shell&amp;gt; python main.py
Before: {}
After: {}
&lt;/code>&lt;/pre>&lt;p>But boy I was wrong. To explain what just happened, let me try to explain how Python imports work.&lt;/p>
&lt;h2 id="how-does-python-import-work-a-simple-version">How does Python import work? (A simple version)&lt;/h2>
&lt;p>In what follows, I only explain what happens when you use &lt;code>import x&lt;/code>. &lt;code>from x import y&lt;/code> is not explained here.&lt;/p>
&lt;p>When you import a module, two steps happen.&lt;/p>
&lt;ol>
&lt;li>Search (done by finder)&lt;/li>
&lt;li>Load (done by loader)&lt;/li>
&lt;/ol>
&lt;p>In the search step, &lt;code>sys.modules&lt;/code> is the first place checked. If the module is not in &lt;code>sys.modules&lt;/code>, Python will search for that module in other ways, current directory being one of them. Once the module(which was not in &lt;code>sys.modules&lt;/code>) is found, it will be added to &lt;code>sys.modules&lt;/code> before step 2 is executed. Thus if &lt;code>a&lt;/code> imports &lt;code>b&lt;/code>, and &lt;code>b&lt;/code> imports &lt;code>c&lt;/code>, and &lt;code>c&lt;/code> imports &lt;code>b&lt;/code>, &lt;code>b&lt;/code> will not be executed again.&lt;/p>
&lt;p>If the module was not found in &lt;code>sys.modules&lt;/code>, the loading step will execute the module and the exported variables will be made available in the importee module.&lt;/p>
&lt;p>One thing you should note is that everything in Python is an object. Even the imported module is. Try this,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> math&lt;span style="color:#f92672">,&lt;/span> types
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">assert&lt;/span> isinstance(math, types&lt;span style="color:#f92672">.&lt;/span>ModuleType)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Objects are stored somewhere in memory. Try this,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>print(hex(id(math)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># printed &amp;#39;0x7f7e21029c20&amp;#39; on my machine&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>So everything in the object module will be available as attributes.&lt;/p>
&lt;p>Now that we know how import works, let&amp;rsquo;s try to see what happened with my code.&lt;/p>
&lt;h2 id="what-happened-with-my-code">What happened with my code?&lt;/h2>
&lt;p>Let&amp;rsquo;s augment the files to print location of &lt;code>var&lt;/code> object. That shall give some ideas.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="587361924" type="checkbox" />
&lt;label for="587361924">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__title">main.py&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Hide" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
import notmain
var = {}
print(&amp;#34;In Main: &amp;#34;, hex(id(var)))
def work():
print(&amp;#34;Before:&amp;#34;, var, &amp;#39;at&amp;#39;, hex(id(var)))
notmain.populate()
print(&amp;#34;After: &amp;#34;, var, &amp;#39;at&amp;#39;, hex(id(var)))
if __name__ == &amp;#39;__main__&amp;#39;:
work()
&lt;/code>&lt;/pre>
&lt;/div>
&lt;div class="collapsable-code">
&lt;input id="435726981" type="checkbox" />
&lt;label for="435726981">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__title">notmain.py&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Hide" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
import main
def populate():
main.var[&amp;#39;answer&amp;#39;] = 42
print(&amp;#39;In not main: &amp;#39;, main.var, &amp;#39;at&amp;#39;, hex(id(main.var)))
&lt;/code>&lt;/pre>
&lt;/div>
&lt;pre tabindex="0">&lt;code>Shell&amp;gt; python main.py
In Main: 0x7f64e4778cc0
In Main: 0x7f64e490c6c0
Before: {} at 0x7f64e490c6c0
In not main: {&amp;#39;answer&amp;#39;: 42} at 0x7f64e4778cc0
After: {} at 0x7f64e490c6c0
&lt;/code>&lt;/pre>&lt;p>First of all notice that &lt;code>In Main: ...&lt;/code> line is printed two times. In the previous section I did tell that &lt;strong>if the module is found in &lt;code>sys.modules&lt;/code>&lt;/strong>, the module will not be executed again. The problem is that &lt;code>main.py&lt;/code> is only imported once, but executed twice.&lt;/p>
&lt;p>Here is what happens.&lt;/p>
&lt;ul>
&lt;li>&lt;code>python main.py&lt;/code> starts executing.&lt;/li>
&lt;li>The first line is &lt;code>import notmain&lt;/code>. Since &lt;code>notmain&lt;/code> is not in &lt;code>sys.modules&lt;/code> yet, it will be executed next. Notice that &lt;code>main&lt;/code> was never imported. So &lt;code>sys.modules&lt;/code> does not have an entry for &lt;code>main&lt;/code>.&lt;/li>
&lt;li>Control goes to &lt;code>notmain.py&lt;/code>. First line of it is &lt;code>import main&lt;/code>, and as &lt;code>main&lt;/code> is not in the cache, finder adds it into &lt;code>sys.modules&lt;/code> and then loader starts executing &lt;code>main.py&lt;/code> (again!).&lt;/li>
&lt;li>Control goes to &lt;code>main.py&lt;/code>. Since the first line is &lt;code>import notmain&lt;/code> and &lt;code>notmain&lt;/code> &lt;strong>is in&lt;/strong> the &lt;code>sys.modules&lt;/code> now, there is no effect.&lt;/li>
&lt;li>Next line in &lt;code>main.py&lt;/code> creates a variable &lt;code>var@0x7f64e4778cc0&lt;/code>.&lt;/li>
&lt;li>Next few lines defines a function &lt;code>work&lt;/code>.&lt;/li>
&lt;li>The &lt;code>__name__ == '__main__'&lt;/code> condition is false, as at the moment &lt;code>__name__ == 'main'&lt;/code>&lt;/li>
&lt;li>Control goes back to &lt;code>notmain.py&lt;/code>. Attributes from the &lt;code>main&lt;/code> module will now be accessible.&lt;/li>
&lt;li>&lt;code>populate&lt;/code> is defined in &lt;code>notmain&lt;/code>.&lt;/li>
&lt;li>Control comes back to &lt;code>main&lt;/code>.&lt;/li>
&lt;li>Variable &lt;code>var&lt;/code> is created (again!) and stored at &lt;code>0x7f64e490c6c0&lt;/code>. Notice that there are two &lt;code>var&lt;/code> variables. &lt;code>notmain&lt;/code> has no idea that there is another &lt;code>var&lt;/code> at &lt;code>0x7f64e490c6c0&lt;/code>, it still thinks that &lt;code>main.var&lt;/code> is at &lt;code>0x7f64e4778cc0&lt;/code>.&lt;/li>
&lt;li>&lt;code>work&lt;/code> function is defined.&lt;/li>
&lt;li>&lt;code>__name__ == '__main__'&lt;/code> condition evaluates to true this time. So &lt;code>work&lt;/code> is called, which calls &lt;code>notmain.populate&lt;/code>.&lt;/li>
&lt;li>&lt;code>notmain.populate&lt;/code> adds &lt;code>answer&lt;/code> key into &lt;code>main.var&lt;/code> and not &lt;code>__main__.var&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>The issue is self-evident now. We need to distinguish between &lt;code>main&lt;/code> and &lt;code>__main__&lt;/code>. A simple solution is to create another file that imports &lt;code>main&lt;/code> and then calls &lt;code>main.work&lt;/code>. This way when &lt;code>notmain&lt;/code> calls import, &lt;code>sys.modules&lt;/code> will already have an entry for &lt;code>main&lt;/code> and &lt;code>main&lt;/code> will not be executed again, and both &lt;code>main&lt;/code> and &lt;code>notmain&lt;/code> have same view of &lt;code>var&lt;/code>. So let&amp;rsquo;s try this.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="653298471" type="checkbox" />
&lt;label for="653298471">
&lt;span class="collapsable-code__language">python&lt;/span>
&lt;span class="collapsable-code__title">really_main.py&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-python" >&lt;code>
import main
main.work()
# no change in other files
&lt;/code>&lt;/pre>
&lt;/div>
&lt;pre tabindex="0">&lt;code>Shell&amp;gt; python really_main.py
Before: {}
After: {&amp;#39;answer&amp;#39;: 42}
&lt;/code>&lt;/pre>&lt;p>Whooo! That worked.&lt;/p>
&lt;h2 id="comments">Comments?&lt;/h2>
&lt;p>You have any doubts? Any feedbacks? Please reach out to me at &lt;code>hello at domain&lt;/code> with subject line &lt;code>Comment: Post title&lt;/code>. I&amp;rsquo;ll get back to you as soon as possible.&lt;/p></content></item></channel></rss>