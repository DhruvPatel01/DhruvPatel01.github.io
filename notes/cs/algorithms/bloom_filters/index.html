<!doctype html><html lang=en><head><title>Bloom Filters :: Dhruv Patel</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='API bf.add(x): adds x in the data structure x in bf: tests if x is in the data structure. Why not use Set or Dict? Bloom filters are more space efficients. They take memory lesser than the keys themselves. Cons can&rsquo;t store associated data. does not support deletions. It is probabilistic data structure. That means, x in bf might have false positives. There are no false negatives. Applications Spell checkers: (40 years ago) Add the dictionary into the filter. If the word is in the bloom filter, it is higly likely tobe correctly spelled word. list of forbidden password. E.g., too common password. Modern applications: Routers, a lot of packets incoming. How does it work? we have a data set S of size |S|. have an array of n bits. $b = \frac{n}{|S|}$ bits per element. have k hash functions. import numpy as np class BitArray: def __init__(self, n): self.array = np.zeros((n >> 3) + 1, dtype=np.uint8) def set(self, i): i, j = divmod(i, 8) self.array[i] = self.array[i] | (1 << j) def get(self, i): i, j = divmod(i, 8) return bool(self.array[i] & (1 << j)) import xxhash def get_hashes_for_str(x, k): # Only h1 and h2 are computed afresh. Remaining hash # functions are just linear combinations of h1 and h2. assert k > 1 h1 = xxhash.xxh64_intdigest(x, seed=42) h2 = xxhash.xxh64_intdigest(x, seed=84) hashes = [h1, h2] for i in range(2, k): hashes.append(h1 + i*h2) return hashes class BloomFilter: def __init__(self, n, k): self.array = BitArray(n) self.k = k self.n = n def add(self, key): for h in get_hashes_for_str(key, self.k): self.array.set(h % self.n) def __contains__(self, key): for h in get_hashes_for_str(key, self.k): if not self.array.get(h % self.n): return False return True text = "correct incorrect".split() bm = BloomFilter(10, 5) for word in text: bm.add(word) for word in text: assert word in bm assert "notcorrect" not in bm Analysis Trade off between erro rate and space required. Data structre will be useful when there is a sweetspot on the tradeoff curve.
'><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://dhruvpatel.dev/notes/cs/algorithms/bloom_filters/><link rel=stylesheet href=https://dhruvpatel.dev/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://dhruvpatel.dev/css/code.min.4f0ccc8439f99bf7f7970298556b94011aabc1fcae743b6842fc3361a2da9ea3.css><link rel=stylesheet href=https://dhruvpatel.dev/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://dhruvpatel.dev/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://dhruvpatel.dev/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://dhruvpatel.dev/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://dhruvpatel.dev/css/main.min.15870410d15d02abd22fb5ef00996f65a00d04b3a7435e9f83831c7c2298de88.css><link rel=stylesheet href=https://dhruvpatel.dev/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://dhruvpatel.dev/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://dhruvpatel.dev/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://dhruvpatel.dev/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://dhruvpatel.dev/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://dhruvpatel.dev/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel="shortcut icon" href=https://dhruvpatel.dev/favicon.png><link rel=apple-touch-icon href=https://dhruvpatel.dev/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Bloom Filters"><meta property="og:description" content='API bf.add(x): adds x in the data structure x in bf: tests if x is in the data structure. Why not use Set or Dict? Bloom filters are more space efficients. They take memory lesser than the keys themselves. Cons can&rsquo;t store associated data. does not support deletions. It is probabilistic data structure. That means, x in bf might have false positives. There are no false negatives. Applications Spell checkers: (40 years ago) Add the dictionary into the filter. If the word is in the bloom filter, it is higly likely tobe correctly spelled word. list of forbidden password. E.g., too common password. Modern applications: Routers, a lot of packets incoming. How does it work? we have a data set S of size |S|. have an array of n bits. $b = \frac{n}{|S|}$ bits per element. have k hash functions. import numpy as np class BitArray: def __init__(self, n): self.array = np.zeros((n >> 3) + 1, dtype=np.uint8) def set(self, i): i, j = divmod(i, 8) self.array[i] = self.array[i] | (1 << j) def get(self, i): i, j = divmod(i, 8) return bool(self.array[i] & (1 << j)) import xxhash def get_hashes_for_str(x, k): # Only h1 and h2 are computed afresh. Remaining hash # functions are just linear combinations of h1 and h2. assert k > 1 h1 = xxhash.xxh64_intdigest(x, seed=42) h2 = xxhash.xxh64_intdigest(x, seed=84) hashes = [h1, h2] for i in range(2, k): hashes.append(h1 + i*h2) return hashes class BloomFilter: def __init__(self, n, k): self.array = BitArray(n) self.k = k self.n = n def add(self, key): for h in get_hashes_for_str(key, self.k): self.array.set(h % self.n) def __contains__(self, key): for h in get_hashes_for_str(key, self.k): if not self.array.get(h % self.n): return False return True text = "correct incorrect".split() bm = BloomFilter(10, 5) for word in text: bm.add(word) for word in text: assert word in bm assert "notcorrect" not in bm Analysis Trade off between erro rate and space required. Data structre will be useful when there is a sweetspot on the tradeoff curve.
'><meta property="og:url" content="https://dhruvpatel.dev/notes/cs/algorithms/bloom_filters/"><meta property="og:site_name" content="Dhruv Patel"><meta property="og:image" content="https://dhruvpatel.dev/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2022-09-29 04:07:39 +0000 UTC"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Dhruv Patel</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;â–¾</li><li><ul class=menu__dropdown><li><a href=/about/>About</a></li><li><a href=https://github.com/DhruvPatel01/>Github</a></li><li><a href=/notes>Notes</a></li><li><a href=/now>Now</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about/>About</a></li><li><a href=https://github.com/DhruvPatel01/>Github</a></li><li><a href=/notes>Notes</a></li><li><a href=/now>Now</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://dhruvpatel.dev/notes/cs/algorithms/bloom_filters/>Bloom Filters</a></h1><div class=post-meta><time class=post-date>2022-09-29</time></div><div class=post-content><div><h2 id=api>API<a href=#api class=hanchor arialabel=Anchor>#</a></h2><ul><li><code>bf.add(x)</code>: adds x in the data structure</li><li><code>x in bf</code>: tests if x is in the data structure.</li></ul><h2 id=why-not-use-set-or-dict>Why not use Set or Dict?<a href=#why-not-use-set-or-dict class=hanchor arialabel=Anchor>#</a></h2><ul><li>Bloom filters are more space efficients. They take memory lesser than the keys themselves.</li></ul><h2 id=cons>Cons<a href=#cons class=hanchor arialabel=Anchor>#</a></h2><ul><li>can&rsquo;t store associated data.</li><li>does not support deletions.</li><li>It is probabilistic data structure. That means, <code>x in bf</code> might have false positives. There are no false negatives.</li></ul><h2 id=applications>Applications<a href=#applications class=hanchor arialabel=Anchor>#</a></h2><ul><li>Spell checkers: (40 years ago) Add the dictionary into the filter. If the word is in the bloom filter, it is higly likely tobe correctly spelled word.</li><li>list of forbidden password. E.g., too common password.</li><li>Modern applications: Routers, a lot of packets incoming.</li></ul><h2 id=how-does-it-work>How does it work?<a href=#how-does-it-work class=hanchor arialabel=Anchor>#</a></h2><ul><li>we have a data set <code>S</code> of size <code>|S|</code>.</li><li>have an array of <code>n</code> bits.</li><li>$b = \frac{n}{|S|}$ bits per element.</li><li>have <code>k</code> hash functions.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BitArray</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, n):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>array <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((n <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>3</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, dtype<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>uint8)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>set</span>(self, i):
</span></span><span style=display:flex><span>        i, j <span style=color:#f92672>=</span> divmod(i, <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>array[i] <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>array[i] <span style=color:#f92672>|</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> j)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get</span>(self, i):
</span></span><span style=display:flex><span>        i, j <span style=color:#f92672>=</span> divmod(i, <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> bool(self<span style=color:#f92672>.</span>array[i] <span style=color:#f92672>&amp;</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> j))
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> xxhash
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_hashes_for_str</span>(x, k):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Only h1 and h2 are computed afresh. Remaining hash </span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># functions are just linear combinations of h1 and h2.</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> k <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    h1 <span style=color:#f92672>=</span> xxhash<span style=color:#f92672>.</span>xxh64_intdigest(x, seed<span style=color:#f92672>=</span><span style=color:#ae81ff>42</span>)
</span></span><span style=display:flex><span>    h2 <span style=color:#f92672>=</span> xxhash<span style=color:#f92672>.</span>xxh64_intdigest(x, seed<span style=color:#f92672>=</span><span style=color:#ae81ff>84</span>)
</span></span><span style=display:flex><span>    hashes <span style=color:#f92672>=</span> [h1, h2]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>, k):
</span></span><span style=display:flex><span>        hashes<span style=color:#f92672>.</span>append(h1 <span style=color:#f92672>+</span> i<span style=color:#f92672>*</span>h2)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> hashes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BloomFilter</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, n, k):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>array <span style=color:#f92672>=</span> BitArray(n)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>k <span style=color:#f92672>=</span> k
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>n <span style=color:#f92672>=</span> n
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(self, key):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> h <span style=color:#f92672>in</span> get_hashes_for_str(key, self<span style=color:#f92672>.</span>k):
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>array<span style=color:#f92672>.</span>set(h <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>n)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __contains__(self, key):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> h <span style=color:#f92672>in</span> get_hashes_for_str(key, self<span style=color:#f92672>.</span>k):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> self<span style=color:#f92672>.</span>array<span style=color:#f92672>.</span>get(h <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>n):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>text <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;correct incorrect&#34;</span><span style=color:#f92672>.</span>split()
</span></span><span style=display:flex><span>bm <span style=color:#f92672>=</span> BloomFilter(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> text:
</span></span><span style=display:flex><span>    bm<span style=color:#f92672>.</span>add(word)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> word <span style=color:#f92672>in</span> text:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span> word <span style=color:#f92672>in</span> bm
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>assert</span> <span style=color:#e6db74>&#34;notcorrect&#34;</span> <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> bm
</span></span></code></pre></div><h2 id=analysis>Analysis<a href=#analysis class=hanchor arialabel=Anchor>#</a></h2><p>Trade off between erro rate and space required. Data structre will be useful when there is a sweetspot on the tradeoff curve.</p><p>Assumption: The hash functions are independent and they distribute the data uniformly.</p><p>Out of n bits, focus on a particular bit. What is the probability that it has been set?</p><p>It is probability of 1 minus it hasn&rsquo;t been set by any of the <code>|S|</code> elements, for any of the <code>k</code> hash functions.</p><p>$p = 1 - (1 - \frac{1}{n})^{k|S|}$.</p><p>As can be seen by the plot below, $1+x$ can be approximated by $e^x$ when x is close to zero. In all cases, $e^x$ is an overestimate of $1+x$.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#66d9ef>as</span> plt
</span></span><span style=display:flex><span>x <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>linspace(<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(x, <span style=color:#ae81ff>1</span><span style=color:#f92672>+</span>x, label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;$1 +x$&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(x, np<span style=color:#f92672>.</span>exp(x), label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;$e^x$&#34;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>legend();
</span></span></code></pre></div><p><img src=/notes/cs/algorithms/bloom_filters/images/63351a0ed542f328049edc91.png alt="output image for above cell"></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&lt;Figure size 640x480 with 1 Axes&gt;
</span></span></code></pre></div><p>Thus, $p \approx 1 - e^{\frac{-k|S|}{n}} = 1 - e^{\frac{-k}{b}}$. Remember, b is the bits per element.</p><p>As $b \to \inf$, $p \to 0$.</p><p>Thus, the probability of false positive is $\epsilon = (1-e^{\frac{-k}{b}})^k$.</p><h2 id=how-to-set-k>How to set K?<a href=#how-to-set-k class=hanchor arialabel=Anchor>#</a></h2><p>Set K optimally. Fix the b, then set k to minimize the error.
Using calculus, $k \approx (ln 2) b$.</p><p>When we plug this back into the p, we get $\epsilon \approx (\frac{1}{2})^\left((ln 2) b\right)$. Notice that error rate is exponential in b.</p><p>Using little bit of algebra we can get $b \approx 1.44 log_2{\frac{1}{\epsilon}}$. (Hint: $1.44 \approx \frac{1}{ln2}$.)</p><h2 id=how-does-theory-differ-from-practice>How does theory differ from practice<a href=#how-does-theory-differ-from-practice class=hanchor arialabel=Anchor>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> string
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> random
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>letters <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array(list(string<span style=color:#f92672>.</span>ascii_letters <span style=color:#f92672>+</span> string<span style=color:#f92672>.</span>digits))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>random_str</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>choice(letters, np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>9</span>)))
</span></span></code></pre></div><p>Generate 1M keys, and insert them in the bloom filter. Just for sanity check, I will test if there is no false negative. Then I will generate keys at random, check if it is in actually there, and how often does bloom filter give false positive. Recall that error rate as a function of b = n/10M is $\approx (\frac{1}{2})^\left((ln 2) b\right)$.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>actually_there <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>set_size <span style=color:#f92672>=</span> int(<span style=color:#ae81ff>1e6</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> len(actually_there) <span style=color:#f92672>!=</span> set_size:
</span></span><span style=display:flex><span>    actually_there<span style=color:#f92672>.</span>add(random_str())
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> tqdm.auto <span style=color:#f92672>import</span> tqdm
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>bs <span style=color:#f92672>=</span> [<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>16</span>]
</span></span><span style=display:flex><span>fpve_rate <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>theory <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> b <span style=color:#f92672>in</span> bs:
</span></span><span style=display:flex><span>    theory<span style=color:#f92672>.</span>append(<span style=color:#ae81ff>.5</span><span style=color:#f92672>**</span>(np<span style=color:#f92672>.</span>log(<span style=color:#ae81ff>2</span>)<span style=color:#f92672>*</span>b))
</span></span><span style=display:flex><span>    bm <span style=color:#f92672>=</span> BloomFilter(b<span style=color:#f92672>*</span>set_size, k<span style=color:#f92672>=</span>int(np<span style=color:#f92672>.</span>log(<span style=color:#ae81ff>2</span>)<span style=color:#f92672>*</span>b))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> key <span style=color:#f92672>in</span> tqdm(actually_there, <span style=color:#e6db74>&#34;Inserting&#34;</span>):
</span></span><span style=display:flex><span>        bm<span style=color:#f92672>.</span>add(key)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> key <span style=color:#f92672>in</span> tqdm(actually_there, <span style=color:#e6db74>&#34;Sanity Checking&#34;</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span> key <span style=color:#f92672>in</span> bm
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    fpve, total <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> total <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10_000</span>:
</span></span><span style=display:flex><span>        key <span style=color:#f92672>=</span> random_str()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> key <span style=color:#f92672>in</span> actually_there: <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> key <span style=color:#f92672>in</span> bm:
</span></span><span style=display:flex><span>            fpve <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        total <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    fpve_rate<span style=color:#f92672>.</span>append(fpve<span style=color:#f92672>/</span>total)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Inserting:   0%|          | 0/1000000 [00:00&lt;?, ?it/s]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Sanity Checking:   0%|          | 0/1000000 [00:00&lt;?, ?it/s]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Inserting:   0%|          | 0/1000000 [00:00&lt;?, ?it/s]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Sanity Checking:   0%|          | 0/1000000 [00:00&lt;?, ?it/s]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Inserting:   0%|          | 0/1000000 [00:00&lt;?, ?it/s]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Sanity Checking:   0%|          | 0/1000000 [00:00&lt;?, ?it/s]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Inserting:   0%|          | 0/1000000 [00:00&lt;?, ?it/s]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Sanity Checking:   0%|          | 0/1000000 [00:00&lt;?, ?it/s]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>bs_lin <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>linspace(bs[<span style=color:#ae81ff>0</span>], bs[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(bs_lin, <span style=color:#ae81ff>.5</span><span style=color:#f92672>**</span>(np<span style=color:#f92672>.</span>log(<span style=color:#ae81ff>2</span>)<span style=color:#f92672>*</span>bs_lin), label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Theory&#34;</span>, c<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;b&#39;</span>) 
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(bs, theory, <span style=color:#e6db74>&#39;o&#39;</span>, c<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;b&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>plot(bs, fpve_rate, <span style=color:#e6db74>&#39;-x&#39;</span>, label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Practice&#34;</span>, c<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;orange&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>legend();
</span></span><span style=display:flex><span>plt<span style=color:#f92672>.</span>xlabel(<span style=color:#e6db74>&#34;bits per element&#34;</span>)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Text(0.5, 0, &#39;bits per element&#39;)
</span></span></code></pre></div><p><img src=/notes/cs/algorithms/bloom_filters/images/63351a0ed542f328049edc92.png alt="output image for above cell"></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&lt;Figure size 640x480 with 1 Axes&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fpve_rate
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>[0.1551, 0.0211, 0.0024, 0.0003]
</span></span></code></pre></div><p>at b=12, false positive rate is already less than 1%</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python></code></pre></div></div></div></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Dhruv Patel</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>